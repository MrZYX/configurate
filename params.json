{"name":"Configurate","tagline":"A flexible configuration system","body":"# Configurate - A flexible configuration system\r\n[![Gem Version](https://badge.fury.io/rb/configurate.png)](https://rubygems.org/gems/configurate)\r\n[![Build Status](https://secure.travis-ci.org/jhass/configurate.png?branch=master)](https://travis-ci.org/jhass/configurate)\r\n[![Gemnasium](https://gemnasium.com/MrZYX/configurate.png)](https://gemnasium.com/MrZYX/configurate)\r\n[![Code Climate](https://codeclimate.com/github/jhass/configurate.png)](https://codeclimate.com/github/MrZYX/configurate)\r\n[![Coverage Status](https://coveralls.io/repos/jhass/configurate/badge.png?branch=master)](https://coveralls.io/r/MrZYX/configurate)\r\n\r\nConfigurate allows you to specify a chain of configuration providers which are\r\nqueried in order until one returns a value. This allows scenarios like overriding\r\nyour default settings with a user configuration file and let those be overridden\r\nby environment variables. The query interface allows to group and nest your configuration options\r\nto a practically unlimited level.\r\n\r\nConfigurate works with Ruby 1.9.2 or later.\r\n\r\n## Installation\r\n\r\nJust add\r\n\r\n```ruby\r\ngem 'configurate'\r\n```\r\n\r\nto your `Gemfile`.\r\n\r\n\r\n## Usage\r\n\r\nA basic loader could look like this:\r\n\r\n```ruby\r\nrequire 'configurate'\r\n\r\nConfig = Configurate::Settings.create do\r\n  add_provider Configurate::Provider::Env\r\n  add_provider Configurate::Provider::YAML, '/etc/app_settings.yml',\r\n               namespace: Rails.env, required: false\r\n  add_provider Configurate::Provider::YAML, 'config/default_settings.yml'\r\nend\r\n\r\n# Somewhere later\r\nif Config.remote_assets.enable?\r\n  set_asset_host Config.remote_assets.host\r\nend\r\n```\r\n\r\nYou can add custom methods working with your settings to your `Configurate::Settings` instance\r\nby calling `extend YourConfigurationMethods` inside the block passed to `#create`.\r\n\r\nProviders are called in the order they're added. You can already use the added providers to\r\ndetermine if further ones should be added:\r\n\r\n```ruby\r\nrequire 'configurate'\r\n\r\nConfig = Configurate::Settings.create do\r\n  add_provider Configurate::Provider::Env\r\n  add_provider Configurate::Provider::YAML, 'config/settings.yml' unless heroku?\r\nend\r\n```\r\n\r\n`add_provider` can be called later on the created object to add more providers to the chain.\r\nIt takes a constant and parameters that should be passed to the initializer.\r\n\r\nA providers only requirement is that it responds to the `#lookup` method. `#lookup` is passed the current\r\n`SettingPath`, for example for a call to `Config.foo.bar.baz?` it gets a path with the items `'foo'`, `'bar'`, `'baz'` passed. `SettingPath` behaves like `Array` with some methods added.\r\nThe provider should raise `Configurate::SettingNotFoundError` if it can't provide a value for the requested option.\r\nAny additional parameters are passed along to the provider, thus a `#lookup` method must be able to take\r\nany number of additional parameters.\r\n\r\nYou're not limited to one instance of the configuration object.\r\n\r\n## Gotchas\r\n\r\n### False\r\n\r\nRuby does not allow to metaprogram `false`, thus something like\r\n\r\n```ruby\r\nputs \"yep\" if Config.enable_stuff\r\n```\r\n\r\nalways outputs `yep`. The workaround is to append `.get`, or `?` to get the\r\nreal value:\r\n\r\n```ruby\r\nputs \"yep\" if Config.enable_stuff?\r\n```\r\n\r\n### Module#===\r\n\r\nAnother thing you can't overwrite in Ruby is the `===` operator, rendering case statements useless\r\n\r\n```ruby\r\nputs case Config.some.setting\r\n     when NilClass\r\n       \"nil\"\r\n     when String\r\n       \"string\"\r\n     else\r\n       \"unknown\"\r\n     end\r\n```\r\n\r\nwill always output `unknown`. Again use `.get`\r\n\r\n\r\n## Shipped providers\r\n\r\n### Configurate::Provider::Base\r\n\r\nA convenience base class changing the interface for implementers. It provides a basic `#lookup` method\r\nwhich just passes all parameters through to `#lookup_path`.\r\nThe result of `#lookup_path` is returned, unless it's `nil`\r\nthen `Configurate::SettingNotFoundError` is raised. Subclasses are expected to implement `#lookup_path`.\r\nDo not use this class directly as a provider!\r\n\r\n### Configurate::Provider::Env\r\n\r\nThis class transforms a query string into a name for a environment variable and looks up this variable then.\r\nThe conversion scheme is the following: Convert to uppercase, join path with underscores. So for example `Config.foo.bar.baz`\r\nwould look for a environment variable named `FOO_BAR_BAZ`. Additionally it splits comma separated values\r\ninto arrays.\r\n\r\nThis provider does not take any additional initialization parameters.\r\n\r\n### Configurate::Provider::YAML\r\n\r\nThis provider reads settings from a given [YAML](http://www.yaml.org) file. It converts the sections of\r\nquery string to a nested value. For a given YAML file\r\n\r\n```yaml\r\nstuff:\r\n  enable: true\r\n  param: \"foo\"\r\n  nested:\r\n    param: \"bar\"\r\n```\r\n\r\nthe following queries would be valid:\r\n\r\n```ruby\r\nConfig.stuff.enable?      # => true\r\nConfig.stuff.param        # => \"foo\"\r\nConfig.stuff.nested.param # => \"bar\"\r\n```\r\n\r\nThe initializer takes a path to the configuration file as mandatory first argument and\r\nthe following optional parameters, as a hash:\r\n\r\n* *namespace:* Specify a alternative root. This is useful if you for example add the same file multiple\r\n  times through multiple providers, with different namespaces, letting you override settings depending on\r\n  the rails environment, without duplicating common settings. Defaults to none.\r\n* *required:* Whether to raise an error if the the file isn't found or, if one is given, the namespace\r\n  doesn't exist in the file.\r\n\r\n### Configurate::Provider::Dynamic\r\n\r\nA provider which stores the first additional parameter if the query string ends with an equal sign and can\r\nreturn it later. This is mainly useful for testing but can be useful to temporarily override stuff too. To clarify a small example:\r\n\r\n```ruby\r\nConfig.foo.bar         # => nil\r\nConfig.foo.bar = \"baz\"\r\nConfig.foo.bar         # => \"baz\"\r\nConfig.reset_dynamic!\r\nConfig.foo.bar         # => nil\r\n```\r\n\r\n## Writing a provider\r\n\r\n...should be pretty easy. For example here is the `Configurate::Provider::Env` provider:\r\n\r\n```ruby\r\nclass Configurate::Provider::Env < Configurate::Provider::Base\r\n  def lookup_path(setting_path, *args)\r\n    value = ENV[setting_path.join(\"_\").upcase]\r\n    unless value.nil?\r\n      value = value.dup\r\n      value = value.split(\",\") if value.include?(\",\")\r\n    end\r\n    value\r\n  end\r\nend\r\n```\r\n\r\n\r\n## Documentation\r\n\r\nYou can find the current documentation for the master branch [here](http://rubydoc.info/github/jhass/configurate/master/frames/index).\r\n\r\n\r\n## License\r\n\r\nMIT, see [LICENSE](./LICENSE)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}